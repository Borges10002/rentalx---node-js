--link https://www.notion.so/Refatora-o-Docker-com-TypeORM-4500fc0d075349ac9b97d670e734d41b

# RefatoraÃ§Ã£o Docker com TypeORM

Faaaaala Dev!

Caso a versÃ£o do seu `docker-compose` seja `1.28` ou maior, vocÃª provavelmente obterÃ¡ o erro `network_mode is incompatible with port_bindings` ao tentar rodar o comando `docker-compose up` para subir seus containers. Esse erro ocorre pois na Ãºltima atualizaÃ§Ã£o o `network_mode` deixou de ser compatÃ­vel com a propriedade `ports` . 

Mas calma, nÃ³s vamos te passar a soluÃ§Ã£o para seu projeto!

### Passo a passo - Leia atÃ© o final ðŸ˜‰

1 - Remova a propriedade `network_mode` no service da aplicaÃ§Ã£o e do banco de dados

2 - No service da aplicaÃ§Ã£o vocÃª precisarÃ¡ colocar as seguintes propriedades:

```yaml
links:
	- database
depends_on: 
	- database
```

A propriedade `depends_on` irÃ¡ informar que nosso serviÃ§o de **api** irÃ¡ depender do serviÃ§o do banco de dados (database). Isso farÃ¡ com que a ordem para os containers subirem seja primeiro o serviÃ§o **database** e depois o da **api**.

A propriedade `links` faz uma ligaÃ§Ã£o entre os containers,  permitindo que o container de destino (api) tenha informaÃ§Ãµes do container de origem(database). 
Dessa forma, nosso service da aplicaÃ§Ã£o agora conseguirÃ¡ se comunicar com nosso banco de dados nÃ£o mais atravÃ©s do IP, mas sim pelo nome do container. 

3 - No arquivo `ormconfig.json` o  **host** deverÃ¡ ser preenchido com o valor **localhost**.  

4 - No arquivo **index.ts**, dentro da pasta **database**, deixar da seguinte forma:

```tsx
import { createConnection, getConnectionOptions } from 'typeorm';

interface IOptions {
  host: string;
}

getConnectionOptions().then(options => {
  const newOptions = options as IOptions;
  newOptions.host = 'database'; //Essa opÃ§Ã£o deverÃ¡ ser EXATAMENTE o nome dado ao service do banco de dados
  createConnection({
    ...options,
  });
});
```

5 - Rodar o comando **docker-compose up -d â€”force-recreate** no terminal, para atualizar as informaÃ§Ãµes do container. 

Para testar, vocÃª pode verificar se a aplicaÃ§Ã£o estÃ¡ rodando, atravÃ©s do comando `docker logs rentx -f`

### IMPORTANTE

Testar tambÃ©m as migrations, com o comando `yarn typeorm migration:run`

Se tudo der certo, vencemos o **DOCKER** ðŸš€

## ExplicaÃ§Ã£o

Mas vocÃª nÃ£o disse que utilizando a propriedade `links` conseguirÃ­amos utilizar o nome do service ao invÃ©s do IP? Por que entÃ£o utilizamos **localhost**  no host do **ormconfig.json?** 

O que acontece Ã© que no momento em que o arquivo **ormconfig** Ã© carregado no sistema para iniciar a nossa aplicaÃ§Ã£o, o **typeorm** nÃ£o consegue utilizar a referÃªncia que criamos na propriedade `links`, por isso utilizamos o `[localhost](http://localhost)` como valor para a propriedade `host` .

Por isso no nosso arquivo de configuraÃ§Ã£o de criaÃ§Ã£o de conexÃ£o (database/index.ts) precisamos sobrescrever o host do nosso banco de dados, nesse momento sim apontando para o valor que colocamos no `links`.  

Certo! Entendi. Mas por que criamos a interface `IOptions` ? 
Boa pergunta! A propriedade `host` por padrÃ£o Ã© uma propriedade somente de leitura. Se tentarmos sobrescrever o valor dela, o typescript recusa. Por esse motivo criamos uma interface, somente com a propriedade `host` e forÃ§amos que o tipo nas nossas `options` seja da interface. Quando fazemos  `const newOptions = options as IOptions` o nosso atributo `newOptions` e `options` se comportam como se fossem o mesmo objeto e aÃ­ com isso conseguimos sobrescrever o valor do host ðŸ™‚

## Arquivos completos

Segue abaixo a configuraÃ§Ã£o completa de cada arquivo

### Ormconfig.json

```json
{
  "type": "postgres",
  "port": 5432,
  "host": "localhost", //Aqui fica como localhost
  "username": "docker",
  "password": "ignite",
  "database": "rentx", 
  "migrations": ["./src/database/migrations/*.ts"],
  "entities": ["./src/modules/**/entities/*.ts"],
  "cli": {
    "migrationsDir": "./src/database/migrations"
  }
}
```

### docker-compose.yml

```yaml
version: "3.9"

services:
  database: #ESSE Ã‰ O NOME DO SERVICE QUE DEVE ESTAR NO ARQUIVO DE CRIAÃ‡ÃƒO DE CONEXÃƒO
    image: postgres
    container_name: database_ignite
    restart: always
    ports: 
      - 5432:5432
    environment:
      - POSTGRES_USER=docker
      - POSTGRES_PASSWORD=ignite
      - POSTGRES_DB=rentx
    volumes:
      - pgdata:/data/postgres

  app:
    build: .
    container_name: rentx
    restart: always
    ports: 
      - 3333:3333
      - 9229:9229 #VocÃª pode inserir essa porta tbm pra poder usar o debug
    volumes: 
      - .:/usr/app
    links: 
      - database
    depends_on:
      - database

volumes:
  pgdata:
    driver: local
```

### index.ts do database

```tsx
import { createConnection, getConnectionOptions } from 'typeorm';

interface IOptions {
  host: string;
}

getConnectionOptions().then(options => {
  const newOptions = options as IOptions;
  newOptions.host = 'database'; //Essa opÃ§Ã£o deverÃ¡ ser EXATAMENTE o nome dado ao service do banco de dados
  createConnection({
    ...options,
  });
});
```

Agora Ã© sÃ³ continuar codando ðŸ˜‰